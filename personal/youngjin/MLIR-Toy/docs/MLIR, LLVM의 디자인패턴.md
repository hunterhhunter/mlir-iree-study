### LLVM의 디자인 패턴
* class 대신 struct를 쓰는 이유는 public 키워드를 최소화하기 위함
*  또 C++ Struct는 전통적으로 데이터 묶음이나 함수 객체라는 뉘앙스를 가지고 있어 MLIR의 RewritePattern이나 Pass의 동작 중심의 객체 설계와도 맞아 떨어짐
* 그리고 또 LLVM/MLIR의 코딩 컨벤션임.
* MLIR의 모든 타입은 유일해야함. 

### MLIR의 타입시스템
- Type은 전역적 유일성이 보장되어야함.
- 타입이 코드에서 얼만큼 쓰이든 메모리 상에서는 단 하나의 객체만 존재해야함.
- 왜? 컴파일러는 타입 비교를 매우 많이 하는데, 그 속도를 줄이기위해 유일성을 보장하고 포인터로만 비교하는 것
- => MLIRContext에서 타입::get 요청이 들어오면 키(Key)생성 -> 해시 비교 -> 조회/생성 과정을 거침

### MLIR의 메모리 관리와 소유권
- MLIR에서 make_unique를 사용해 소유권을 관리하는데 이는 C++의 스마트 포인터를 사용하는 것으로 해당 객체의 메모리 관리 책임을 호출자에게 넘긴다.
- 객체가 여러개 생성될 수 있지만, 수명 관리를 명확하게 하기위해 스마트 포인터를 쓰는 것