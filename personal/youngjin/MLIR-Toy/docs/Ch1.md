# MLIR Toy Tutorial Chapter 1: Lexer, AST, Parser 분석

## 1. 개요
* **목표:** 언어의 프론트엔드(Frontend) 기초인 Lexer, Parser, AST를 구현하여 소스 코드를 구조화된 데이터(AST)로 변환
* **학습 자료:**
    * **웹 튜토리얼:** 핵심 논리와 개념 위주 설명.
    * **GitHub 코드:** 실제 컴파일 가능한 상세 구현 (`#include`, 에러 처리, 헬퍼 클래스 등) 포함.

---

## 2. Lexer (어휘 분석기)
소스 코드를 읽어 의미 있는 단위인 **토큰(Token)**으로 분리하는 역할.

### 🔹 토큰 정의 (Enum Token)
* **구분자:** `;`, `(`, `)`, `{`, `}`, `[`, `]`
* **키워드:** `return`, `var`, `def`
* **데이터:** `identifier` (식별자), `number` (숫자), `EOF` (파일 끝)

### 🔹 핵심 메서드
| 메서드 | 설명 |
| :--- | :--- |
| **`getTok()`** | `while`문을 순회하며 한 단어를 토큰화 및 분류(identifier, number, 주석, EOF)하여 반환 |
| **`getNextChar()`** | 다음 문자를 읽어오는데 `\n`과 `EOF` 예외 처리를 수행 |
| **`consume()`** | 현재 토큰을 소비하고 다음 토큰을 미리 가져옴 (`getNextToken` 사용) |
| **`getLoc()`** | 현재 토큰의 위치 정보(`Location`: line, col) 반환 |
| **`LexerBuffer`** | (구현 상세) `readNextLine`을 통해 다음 줄 전체를 `llvm::StringRef`로 효율적으로 읽어옴 |

---

## 3. AST (추상 구문 트리)
파싱된 토큰들을 계층적 구조(Node)로 정의. 모든 노드는 부모 클래스인 **`ExprAST`**를 상속받아 관리된다.

### 🔹 노드 종류
| 노드 클래스 | 역할 |
| :--- | :--- |
| **`VarDeclExprAST`** | 변수 선언 및 정의 (`var a = ...`) |
| **`ReturnExprAST`** | 값 반환 (`return ...`) |
| **`NumberExprAST`** | 숫자 리터럴 (`1.0`) |
| **`LiteralExprAST`** | 배열/텐서 리터럴 (`[1, 2, 3]`) |
| **`BinaryExprAST`** | 이항 연산자 (피연산자 2개) |
| **`CallExprAST`** | 함수 호출 (`myFunc(a)`) |
| **`PrintExprAST`** | 내장 출력 함수 |

### 🔹 설계 특징
1.  **소유권 관리 (`std::move`):** 디버깅을 위한 `Location` 정보 등 무거운 데이터는 `std::move`를 사용해 복사 비용 없이 소유권을 부모(`ExprAST`)로 넘긴다.
2.  **LLVM Style RTTI (`classof`):**
    * 표준 C++의 `dynamic_cast`나 `typeid`는 오버헤드가 큼.
    * 대신 `kind` 열거형과 `classof` 정적 메서드를 직접 구현하여, 부모 포인터가 실제 어떤 자식 클래스인지 **빠르고 가볍게 확인**하는 시스템을 구축.

---

## 4. Parser (구문 분석기)
Lexer가 생성한 토큰을 조립하여 실제 AST(ExprAST 객체들)를 생성한다.

* **구조 관리:** 논리적으로는 트리 구조이나, 자식 노드들의 목록(예: 블록 내부의 코드들)을 관리할 때는 `std::vector`를 활용하여 효율성을 높임.
* **에러 처리:** 템플릿 함수 `parseError`를 구현하여, 파싱 실패 시 커스텀 에러 메시지와 함께 `nullptr`를 반환하도록 처리.

---

## 💡 문법 & 디자인 패턴 정리 (Key Learnings)

### 1. Modern C++ 문법
* **`using name = ...` (Type Alias):** `typedef`와 유사하지만 더 직관적인 문법. 복잡한 자료형을 이해하기 쉬운 이름으로 정의하여 가독성을 높임.
* **`llvm::StringRef`:** `std::string`의 가벼운 뷰(View). 문자열 복사 없이 원본을 참조만 하므로 매우 빠름. `std::string`에서 암시적 변환을 지원함.
* **Template Argument (`typename R, T`):** 컴파일러가 타입을 자동으로 추론하게 하여 제네릭하고 유연한 코드 작성을 도움.

### 2. 메모리 및 객체 관리
* **`std::move` (이동 시맨틱):**
    * 무거운 객체나 `unique_ptr`의 소유권을 이전할 때 사용.
    * 내부적으로는 인자가 **참조자(`&&`)**로 캐스팅되며, 포인터만 **얕은 복사** 후 원본을 `nullptr`로 만들어 복사 비용을 없앰. (참조 카운트 유지 등 효율j적 관리)
* **객체 반환 전략:**
    * 객체를 값으로 반환하면 복사가 발생하므로, `std::unique_ptr<ExprAST>`와 같이 **스마트 포인터**를 반환하여 복사를 방지하고 소유권만 이전함.
* **객체 절단 (Object Slicing) 방지:**
    * 자식 클래스를 부모 클래스 타입(값)으로 반환하면 자식만의 데이터가 잘려나감. 이를 방지하기 위해 반드시 포인터나 참조자 형태로 다뤄야 함.

### 3. 기타 테크닉
* **참조자(`&`) vs 포인터(`*`):** 포인터는 `->`로 역참조하여 접근하고, 참조자는 `.`으로 원본 자체에 접근함.
* **`vector::back()` 주의사항:**
    * `back()`은 마지막 원소의 **참조**를 반환함.
    * **중요:** 벡터가 비어있을 때 호출하면 미정의 동작(Undefined Behavior)이 발생하므로, 반드시 `!empty()`를 먼저 확인해야 함.