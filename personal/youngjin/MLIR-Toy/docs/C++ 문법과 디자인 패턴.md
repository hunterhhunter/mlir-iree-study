## 💡 문법 & 디자인 패턴 정리 (Key Learnings)

### 1. Modern C++ 문법
* **`using name = ...` (Type Alias):** `typedef`와 유사하지만 더 직관적인 문법. 복잡한 자료형을 이해하기 쉬운 이름으로 정의하여 가독성을 높임.
* **`llvm::StringRef`:** `std::string`의 가벼운 뷰(View). 문자열 복사 없이 원본을 참조만 하므로 매우 빠름. `std::string`에서 암시적 변환을 지원함.
* **Template Argument (`typename R, T`):** 컴파일러가 타입을 자동으로 추론하게 하여 제네릭하고 유연한 코드 작성을 도움.

### 2. 메모리 및 객체 관리
* **`std::move` (이동 시맨틱):**
    * 무거운 객체나 `unique_ptr`의 소유권을 이전할 때 사용.
    * 내부적으로는 인자가 **참조자(`&&`)**로 캐스팅되며, 포인터만 **얕은 복사** 후 원본을 `nullptr`로 만들어 복사 비용을 없앰. (참조 카운트 유지 등 효율j적 관리)
* **객체 반환 전략:**
    * 객체를 값으로 반환하면 복사가 발생하므로, `std::unique_ptr<ExprAST>`와 같이 **스마트 포인터**를 반환하여 복사를 방지하고 소유권만 이전함.
* **객체 절단 (Object Slicing) 방지:**
    * 자식 클래스를 부모 클래스 타입(값)으로 반환하면 자식만의 데이터가 잘려나감. 이를 방지하기 위해 반드시 포인터나 참조자 형태로 다뤄야 함.

### 3. 기타 테크닉
* **참조자(`&`) vs 포인터(`*`):** 포인터는 `->`로 역참조하여 접근하고, 참조자는 `.`으로 원본 자체에 접근함.
* **`vector::back()` 주의사항:**
    * `back()`은 마지막 원소의 **참조**를 반환함.
    * **중요:** 벡터가 비어있을 때 호출하면 미정의 동작(Undefined Behavior)이 발생하므로, 반드시 `!empty()`를 먼저 확인해야 함.

### 4. LLVM의 디자인 패턴
* class 대신 struct를 쓰는 이유는 public 키워드를 최소화하기 위함
*  또 C++ Struct는 전통적으로 데이터 묶음이나 함수 객체라는 뉘앙스를 가지고 있어 MLIR의 RewritePattern이나 Pass의 동작 중심의 객체 설계와도 맞아 떨어짐
* 그리고 또 LLVM/MLIR의 코딩 컨벤션임.

## 4. 컴파일러 설계 패턴: Interface & Trait
MLIR의 확장성과 최적화 성능을 뒷받침하는 핵심 아키텍처 패턴

### **Trait (연산의 정적 특성)**
* **개념:** 연산이 가진 고유한 성질을 나타내는 명찰입니다. (예: `Pure`, `Terminator`, `SameOperandsAndResultType`)
* **Mixin 패턴:** **CRTP(Curiously Recurring Template Pattern)**를 통해 구현되어, 런타임 오버헤드 없이 연산 클래스에 공통 기능을 주입합니다.
* **역할:** 최적화 패스(Pass)가 연산의 세부 로직을 몰라도 "이 연산은 삭제해도 안전한가?"와 같은 정보를 즉시 판단하게 합니다.

### **OpInterface (연산의 동적 행동)**
* **개념:** 연산이 수행할 수 있는 "능력"을 정의하는 규약입니다. (예: `ShapeInferenceOpInterface`)
* **정적 다형성:** **Concept-Model 디자인 패턴**을 사용하여 가상 함수 테이블(`vtable`) 없이도 서로 다른 연산들의 메서드를 호출할 수 있는 정적 다형성을 구현합니다.
* **역할:** 패스가 개별 연산의 정체를 몰라도 인터페이스 메서드(`inferShapes()` 등)를 통해 공통된 분석을 수행할 수 있도록 디커플링(Decoupling)을 제공합니다.

### **DeclareOpInterfaceMethods (선언과 구현의 계약)**
* **TableGen의 역할:** ODS(`.td`) 파일에 이 트레이트를 선언하면 컴파일러가 C++ 헤더 파일에 메서드 선언문을 자동으로 생성합니다.
* **개발자의 책임:** 선언은 자동이지만 실제 비즈니스 로직(구현부)은 반드시 `.cpp` 파일에 직접 작성해야 하며, 이는 컴파일 타임에 기능 구현을 강제하는 안전장치로 작동합니다.

### **Dialect Interface (방언 수준의 정책)**
* **개념:** 특정 연산이 아닌 다이얼렉트 전체에 적용되는 광범위한 정책입니다.
* **역할:** 인라이너(Inliner)와 같은 범용 엔진이 해당 다이얼렉트의 특수한 규칙(예: 인라이닝 허용 여부, 캐스트 생성 방식)을 동적으로 확인할 수 있는 통로가 됩니다.

