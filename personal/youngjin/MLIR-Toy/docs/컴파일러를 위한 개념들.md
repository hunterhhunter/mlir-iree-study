이 문서는 MLIR을 공부하며 컴파일러에서 사용되는 자료구조, 이론적 개념들에 대해 기록합니다.

### SSA (Static Single Assignment)
정적 단일 할당이라는 뜻으로 컴파일러의 핵심 규칙이 됨.
"**모든 변수는 IR 상에서 오직 한 번만 정의(할당)되어야 한다.**"를 의미함.

코드로 예시를 들어보자면

일반적인 코드 (C언어)
```C
int x = 1;
x = x + 2;
print(x);
```
여기서 x는 처음에 1이었다가 나중에 3으로 바뀜. 즉, x라는 변수의 내용물이 바뀜

SSA 형태의 IR (MLIR/LLVM)
```MLIR
%x1 = toy.constant 1
%x2 = toy.add %x1, %cst_2
toy.print %x2
```
SSA에서는 x라는 이름 대신 **%x1, %x2**처럼 매번 새로운 변수를 만듭니다. 한 번 만들어진 %x1은 영원히 1이며, 절대 다른 값으로 바뀌지 않음.

#### 그럼 왜 쓰는가?
1. **데이터 흐름 파악 용이**: 모든 값의 정의가 단 하나뿐이라서 특정 값이 어디 사용되는지를 추적하는게 단순한 포인터 연결로 바뀜
2. **죽은 코드 제거**: 만약 %2를 정의 후 아무도 쓰지 않으면 %2를 정의하는 줄 자체를 제거 가능
3. **상수 전파**: %1이 1이라는 것을 한 번 알면, 코드에 있는 모든 %1을 1로 치환할 수 있음. 값이 중간에 바뀔 우려가 없기 때문

#### 인라이닝에서의 SSA
함수의 형식 인자(%arg0)가 들어갈 자리에, 호출부에서 넘겨준 실제 SSA 값(%n - main_value)을 심볼 테이블에 insert
---
### 스코프 기반 심볼 테이블 (Scoped Symbol Table)
컴파일러가 코드를 읽어 내려갈 때, 중첩된 함수나 블록에 따라 변수의 유효 범위가 달라짐.
이를 관리하기 위해 사용하는 테이블로 스택 형태의 딕셔너리로 이해하고 있음.

1. 구조적 특징
    - 딕셔너리 (Map): 특정 스코프(예: 함수 내부)에서 선언된 변수명 : SSA값 쌍을 저장.
    - 스택: 스코프가 깊어질 때(중첩될 때) 새로운 딕셔너리를 Push하고, 스코프가 끝날 때 
    Pop함.
    - RAII 패턴 활용: mlirGen 메서드 내부의 ScopedHashTableScope는 C++의 RAII(Resource Acquisition Is Initialization) 패턴을 사용함. 객체가 생성될 때 자동으로 스택에 Push되고, 함수가 끝날 때(객체가 파괴될 때) 자동으로 Pop되도록 설계되어 있어 개발자의 실수를 방지함.
2. 동작 원리
    - 변수 등록 (Insert): 현재 가장 위에 있는(top) 딕셔너리에 새 변수와 SSA값을 기록.
    - 변수 검색 (LookUp):
        1. 최상단 딕셔너리에서 먼저 검색
        2. 없으면 아래 단계로 내려가며 검색
        3. 이는 같은 이름의 변수가 더 깊은 곳에서 선언될 때 이전 변수를 가리는 현상을 구현함 (Shadowing)

#### MLIR에서의 실제 구현과 사용
llvm에서 이 심볼테이블을 구현해두어서 `llvm::ScopedHashTable<StringRef, mlir::Value>`로 사용 가능하다.

실제 사용은 MLIRGen.cpp의 MLIRGenImpl 클래스를 보면 알 수 있다.
Module 단위로 생성되는 MLIRGenImpl 클래스의  멤버변수로 심볼 테이블이 존재하는데 
`mlir::toy::FuncOp mlirGen(FunctionAST &funcAST)` 메서드를 보면 진입하자마자 심볼 테이블을 하나 더 생성하는 것을 볼 수 있다.

#### 인라이닝에서의 심볼테이블
함수 내부 코드를 복제할 때, 심볼 테이블을 LookUp하여 %arg0 대신 %n을 쓰도록 연결
---
### [인사이트] SSA와 심볼 테이블의 연결고리
심볼 테이블의 역할: 사용자가 작성한 **'가변적인 변수명(Mutable Name)'**을 관리함.

SSA의 역할: 컴파일러가 다루는 **'불변의 데이터 흐름(Immutable Data Flow)'**을 관리함.

상호작용: 컴파일러가 코드를 읽으며 심볼 테이블의 딕셔너리를 업데이트할 때마다, 새로운 SSA 버전이 생성됨.